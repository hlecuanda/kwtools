#!/bin/zsh
#
# Autor: Kai Wilke <kiste@netzworkk.de> 07.09.2016
#
# Script: kwbtrfs, bearbeitet btrfs Dateisysteme.
# Version: 0.0.1
#
# Ausfuehren von Befehlen auf bestimmte Signale.
# Notiz. Immer den Namen verwenden, da es auf einigen OS
# eine andere Numerierung geben kann.
#
trap 'setterm --inversescreen off ; setterm --reset ;
umount_dev ; rm -rf $gv_Script_Lock $gv_WorkDir &>/dev/null' EXIT INT

gv_ScriptName=${0##*/}

# Verzeichniss in denen nach Funktionen gesucht wird
#
if [ -f /usr/local/share/kwtools/functions/sys/script_init ] ; then
	PREFIX=/usr/local
else
	PREFIX=/usr
fi
Script_init_Fpath="${PREFIX}/share/kwtools/functions/sys"
export TEXTDOMAINDIR="${PREFIX}/share/locale"
export TEXTDOMAIN="$gv_ScriptName"

if [ -z ${(M)${FPATH}##*${Script_init_Fpath}*} ] ; then
	FPATH=${Script_init_Fpath}:${FPATH}
fi

# script_init enthaelt die globalen Scripteinstellungen und laedt
# diese automatisch.
#
autoload -U script_init

# Scriptinitialisierung
script_init

# Pruefen, ob btrfs installiert ist.
prog_check btrfs mkfs.btrfs
if [[ -n $NO_PROGS ]] ; then
	exit 0
fi

# Pruefen, ob die Version von btrfs die richtige ist.
Version=${${(M)$(btrfs --version)##*v*}#v}
if [[ $Version < 4.5.2 ]] ; then
	MSG=$(gettext 'Sie benoetigen eine btrfs ($Version) Version die groesser oder gleich 4.5.2 ist.')
	msgbox "$gv_Info" "$MSG"
	exit 0
fi

# Pruefen, ob man der Benutzer root ist.
root_check

# Nachdem das Script initialisiert wurde, kann man die anderen
# benoetigten Funktionen laden. Die Funktion sys_conf wird bereits
# von der Funktion script_init ausgefuehrt.
# autoload -U ...

# Variablen
lv_Btrfs_Drive=$(gettext 'btrfs Laufwerk')
lv_Balance=$(gettext 'Metadatenabgleich')
lv_Defrag=$(gettext 'Defragmentierung')
lv_Scan=$(gettext 'scannen')
lv_Filesystem=$(gettext 'Dateisystem')
lv_Subvolumes=$(gettext 'Subvolumes')
lv_Drive=$(gettext 'Laufwerk')
lv_Devices=$(gettext 'Laufwerke')
BTRFS_MSG=$(gettext 'Waehlen Sie ein $lv_Btrfs_Drive aus.')
#
CONF="/etc/kwtools/kwbtrfs.cf"

# Wenn es eine KONFIGURATIONSRC Datei gibt einlesen.
read_file -f $CONF

# Funktion main_menu# {{{
#
main_menu() {
    MAIN_MENU=($gv_Configuration \"\" $lv_Filesystem \"\" $lv_Subvolumes \"\"
		$lv_Devices \"\" $lv_Balance \"\" $gv_Exit \"\")
	menubox "$1" "$gv_Configuration" "$gv_Menupoint" "$MAIN_MENU"
}
## }}}
	# Funktion (btrfs_drive_choice_menu), btrfs Laufwerk auswaehlen# {{{
	btrfs_drive_choice_menu() {
		BTRFS_MENU=($BTRFS_DEV_E $gv_Back \"\")
		menubox "$1" "$lv_Drive" "$BTRFS_MSG" "$BTRFS_MENU"
	}
	## }}}
# Funktion (search_btrfs_filesystem), sucht nach Devices mit btrfs Dateisystem# {{{
#
# usage: search_btrfs_filesystem
#
search_btrfs_filesystem() {
	unset -- BTRFS_DEV BTRFS_DEV_E BTRFS_DEV_M BTRFS_LABEL_DEV BTRFS_LABEL_DEV_E \
		BTRFS_LABEL_DEV_M BTRFS_DEV BTRFS_DEV_E BTRFS_DEV_M BTRFS_UUID_DEV \
		BTRFS_UUID_DEV_E BTRFS_UUID_DEV_M
	local dev label uuid
	btrfs filesystem show > ${gv_WorkDir}/btrfs-all-devices.txt
	if [ "`wc -l <${gv_WorkDir}/btrfs-all-devices.txt`" -gt 1 ] ; then
		while read a b c d rest ; do 
			case $a in
				Label:)
					# Label und UUID uebernehmen
					label="${b//\'/}"
					uuid="$d"
					BTRFS_LABEL_DEV+=($label)
					BTRFS_LABEL_DEV_E+=($label \"\")
					BTRFS_LABEL_DEV_M+=($label \"\" off)
					BTRFS_UUID_DEV+=($uuid)
					BTRFS_UUID_DEV_E+=($uuid \"\")
					BTRFS_UUID_DEV_M+=($uuid \"\" off)
					if [[ $label != none ]] ; then
						btrfs filesystem show $label > ${gv_WorkDir}/btrfs-device.txt
						Dev_Anz="`awk '/Total devices/{print $3}' ${gv_WorkDir}/btrfs-device.txt`"
					elif [[ $uuid != none ]] ; then
						btrfs filesystem show $uuid > ${gv_WorkDir}/btrfs-device.txt
						Dev_Anz="`awk '/Total devices/{print $3}' ${gv_WorkDir}/btrfs-device.txt`"
					fi
					# Devices auflisten
					if (( $Dev_Anz > 1 )) ; then
						parse_uuid_label $uuid
						BTRFS_DEV+=($REALDEV)
						BTRFS_DEV_E+=($REALDEV \"\")
						BTRFS_DEV_M+=($REALDEV \"\" off)
						while read a rest ; do
							case $a in
								devid)
									# Device uebernehmen	
									dev=${rest##* }
									BTRFS_MD+=($dev)
									BTRFS_MD_E+=($dev \"\")
									BTRFS_MD_M+=($dev \"\" off)
									;;
							esac
						done < ${gv_WorkDir}/btrfs-device.txt
					else
						dev="`awk '/devid/{print $8}' ${gv_WorkDir}/btrfs-device.txt`"
						BTRFS_DEV+=($dev)
						BTRFS_DEV_E+=($dev \"\")
						BTRFS_DEV_M+=($dev \"\" off)
					fi
					;;
#				devid)
#					# Device uebernehmen	
#					dev=${rest##* }
#					BTRFS_DEV+=($dev)
#					BTRFS_DEV_E+=($dev \"\")
#					BTRFS_DEV_M+=($dev \"\" off)
#					;;
			esac
		done < ${gv_WorkDir}/btrfs-all-devices.txt
	fi
}
## }}}
# Funktion (search_devices), sucht Partitionen, RAID Arrays, LVs und Cryptsetup# {{{
# Laufwerke
#
# usage: search_devices [ -a | -c | -e | -p ]
# -a - alle; Partitionen, Laufwerke mit Software RAID, LV oder Cryptsetup
# -c - Cryptsetup Laufwerke
# -e - ext[234] Laufwerke
# -p - Partitionen
#
search_devices() {
	unset -- FS NO_BTRFS_DEV NO_BTRFS_DEV_E NO_BTRFS_DEV_M
	case $1 in
		-a)
			# alle Laufwerke suchen
			#
			# vorhandene BTRFS Laufwerke suchen zum heraus filtern
			# von Laufwerken eines BTRFS RAID Arrays.
			search_btrfs_filesystem
			if [ -n "${BTRFS_MD[1]}" ] ; then
				for dev in ${=PART} ${=MD_DEV} ${=LV} ${=CRYPT_DEV} ; {
					if [ -z ${(M)${BTRFS_MD}##$dev} ] ; then
						check_fs $dev
						NO_BTRFS_DEV+=($dev)
						NO_BTRFS_DEV_E+=($dev \"$gv_Fs\")
						NO_BTRFS_DEV_M+=($dev \"$gv_Fs\" off)
					fi
				}
			else
				for dev in ${=PART} ${=MD_DEV} ${=LV} ${=CRYPT_DEV} ; {
					check_fs $dev
					NO_BTRFS_DEV+=($dev)
					NO_BTRFS_DEV_E+=($dev \"$gv_Fs\")
					NO_BTRFS_DEV_M+=($dev \"$gv_Fs\" off)
				}
			fi
			;;
		-c)
			# nur Cryptsetup Laufwerke suchen
			#
			# vorhandene BTRFS Laufwerke suchen zum heraus filtern
			# von Laufwerken eines BTRFS RAID Arrays.
			search_btrfs_filesystem
			if [ -n "${BTRFS_MD[1]}" ] ; then
				for dev in  ${=CRYPT_DEV} ; {
					if [ -z ${(M)${BTRFS_MD}##$dev} ] ; then
						check_fs $dev
						NO_BTRFS_DEV+=($dev)
						NO_BTRFS_DEV_E+=($dev \"$gv_Fs\")
						NO_BTRFS_DEV_M+=($dev \"$gv_Fs\" off)
					fi
				}
			else
				for dev in  ${=CRYPT_DEV} ; {
					check_fs $dev
					NO_BTRFS_DEV+=($dev)
					NO_BTRFS_DEV_E+=($dev \"$gv_Fs\")
					NO_BTRFS_DEV_M+=($dev \"$gv_Fs\" off)
				}
			fi
			;;
		-e)
			# alle ext[234] Laufwerke suchen
			for dev in ${=PART} ${=MD_DEV} ${=LV} ${=CRYPT_DEV} ; {
				check_fs $dev
				case $gv_Fs in
					ext[234])
						NO_BTRFS_DEV+=($dev)
						NO_BTRFS_DEV_E+=($dev \"$gv_Fs\")
						NO_BTRFS_DEV_M+=($dev \"$gv_Fs\" off)
						# wird benoetigt beim konvertieren fuer fsck
						FS+=($gv_Fs)
						;;
				esac
			}
			;;
		-p)
			# nur Partitionen suchen
			#
			# vorhandene BTRFS Laufwerke suchen zum heraus filtern
			# von Laufwerken eines BTRFS RAID Arrays.
			search_btrfs_filesystem
			if [ -n "${BTRFS_MD[1]}" ] ; then
				for dev in ${=PART} ; {
					if [ -z ${(M)${BTRFS_MD}##$dev} ] ; then
						check_fs $dev
						NO_BTRFS_DEV+=($dev)
						NO_BTRFS_DEV_E+=($dev \"$gv_Fs\")
						NO_BTRFS_DEV_M+=($dev \"$gv_Fs\" off)
					fi
				}
			else
				for dev in ${=PART} ; {
					check_fs $dev
					NO_BTRFS_DEV+=($dev)
					NO_BTRFS_DEV_E+=($dev \"$gv_Fs\")
					NO_BTRFS_DEV_M+=($dev \"$gv_Fs\" off)
				}
			fi
			;;
	esac
}
## }}}
# Funktion (mount_btrfs_dev_check), falls die btrfs Devices nicht eingebunden sind# {{{
# wird es jetzt getan.
#
# usage: mount_btrfs_dev_check
#
mount_btrfs_dev_check() {
	unset -- BTRFS_PATH BTRFS_PATH_E BTRFS_PATH_M
	for i in ${=BTRFS_DEV} ; {
		mount_check -c $i
		if [[ $MOUNT == no ]] ; then
			mkdir ${gv_WorkDir}/${i##*/} &>/dev/null
			if mount -t btrfs $i ${gv_WorkDir}/${i##*/} &>/dev/null ; then
				MOUNT_DEVS+=(${gv_WorkDir}/${i##*/})
				BTRFS_PATH+=(${gv_WorkDir}/${i##*/})
				BTRFS_PATH_E+=(${gv_WorkDir}/${i##*/} \"\")
				BTRFS_PATH_M+=(${gv_WorkDir}/${i##*/} \"\" off)
			fi
		else
			BTRFS_PATH+=($MOUNTPOINT)
			BTRFS_PATH_E+=($MOUNTPOINT \"\")
			BTRFS_PATH_M+=($MOUNTPOINT \"\" off)
		fi
	}
}
## }}}
# Funktion (btrfs_dev_checklist), btrfs Laufwerke zur Auswahl anzeigen# {{{
#
btrfs_dev_checklist() {
	if [[ ${#argv} -ge 1 ]] ; then
		TITLE="$1"
		MENU=($BTRFS_PATH_M)
		MSG=$(gettext 'Waehlen Sie ein oder mehrere btrfs Laufwerke aus.')
		checklist "$2" "$TITLE" "$MSG" "$MENU"
	else
		no_para_msg $0
	fi
}
## }}}
# Funktion (umount_dev), bindet alle Laufwerke aus die ins Arbeitsverzeichnis# {{{
# eingebunden wurden.
#
umount_dev() {
	if [[ -n ${MOUNT_DEVS[1]} ]] || [[ -n ${SUBVOL_MOUNT_DEVS[1]} ]] ; then
		for i in ${=SUBVOL_MOUNT_DEVS} ${=MOUNT_DEVS} ; {
			mount_check -a $i
		}
	fi
}
## }}}
# Funktion (no_btrfs_dev_msg), Nachricht das keine Laufwerke mit BTRFS vorhanden sind# {{{
#
no_btrfs_dev_msg() {
	MSG=$(gettext 'Es sind keine Laufwerke mit dem btrfs Dateisystem vorhanden.')
	msgbox "$gv_Info" "$MSG"
}
## }}}
# Funktion (no_free_dev_msg), Nachricht das keine freien Laufwerke vorhanden sind# {{{
#
no_free_dev_msg() {
	MSG=$(gettext 'Es sind keine freien Laufwerke vorhanden.')
	msgbox "$gv_Info" "$MSG"
}
## }}}
# Funktion (no_btrfs_md_dev_msg), Nachricht das keine BTRFS Laufwerke,# {{{
# welche aus mehreren Laufwerken bestehen, vorhanden sind.
#
no_btrfs_md_dev_msg() {
	MSG=$(gettext 'Es sind keine btrfs Laufwerke, welche aus mehreren Laufwerken (z.B RAID) bestehen, vorhanden.')
	msgbox "$gv_Info" "$MSG"
}
## }}}
# Funktion (btrfs_choice_menu), btrfs Laufwerke zur Auswahl anzeigen# {{{
#
btrfs_choice_menu() {
	if [[ ${#argv} == 3 ]] ; then
		MENU=($3 $gv_Back \"\")
		menubox "$1" "$2" "$BTRFS_MSG" "$MENU"
	else
		no_part_msg $0
		return 1
	fi
	return 0
}
## }}}
# Funktion (btrfs_choice_checklist), mehrere btrfs Laufwerke zur Auswahl anzeigen# {{{
#
btrfs_choice_checklist() {
	if [[ ${#argv} == 3 ]] ; then
		MENU=($3)
		checklist "$1" "$2" "$BTRFS_MSG" "$MENU"
	else
		no_part_msg $0
		return 1
	fi
	return 0
}
## }}}

##################################################################
#
# Hauptprogramm
#
##################################################################
#
hw_conf
fs_conf

# nach Festplatten suchen
disk
if [[ -z ${DISK_DEV[1]} ]] ; then
    no_disks_msg
    exit 0
fi

# nach Linux Partitionen auf allen Festplatten suchen
partdb
if [[ -z ${PART[1]} ]] ; then
	no_part_msg
    exit 0
fi

# RAID Arrays erkennen
if [[ -x ${commands[mdadm]} ]] ; then
	raid

fi
# Logische Volumes erkennen
if [[ -x ${commands[lvm]} ]] ; then
	lvm_version
	lv
fi
# cryptsetup Laufwerke erkennen
if [[ -x ${commands[cryptsetup]} ]] ; then
	search_cryptdev -a
	if [[ -n ${MAP_DEV_E[1]} ]] ; then
		unset -- CRYPT_DEV
		for i in ${=MAP_DEV_E} ; {
			CRYPT_DEV+=(/dev/mapper/${i})
		}
	fi
fi

main_menu
while [ "$gv_Auswahl" ] ; do
	case $gv_Auswahl in
		HELP*)
    	    # Hilfe Messagebox
			script_help help
			main_menu "${gv_Auswahl#HELP }"
			;;
		$gv_Configuration)
			# Konfiguration# {{{
			autoload -U kwbtrfs_conf
			kwbtrfs_conf
			## }}}
			main_menu $gv_Configuration
			;;
		$lv_Filesystem)
			# Dateisystem # {{{
			lv_Detail=$(gettext 'detaillierte Information')
			lv_Df=$(gettext 'Blockbelegung')
			lv_Label=$(gettext 'Label')
			# Funktion (filesystem_menu)# {{{
			#
			filesystem_menu() {
				MENU=($gv_Display \"\" \"$lv_Detail\" \"\" $lv_Df \"\" $lv_Defrag \"\"
				$lv_Label \"\" $gv_Enlarge \"\" $gv_Reduce \"\" $gv_Back \"\")
				menubox "$1" "$lv_Filesystem" "$gv_Menupoint" "$MENU"
			}
			## }}}
			search_btrfs_filesystem
			if [[ -n ${BTRFS_DEV[1]} ]] ; then
				filesystem_menu
				while [[ -n $gv_Auswahl ]] ; do
					case $gv_Auswahl in
						HELP*)
							# Hilfe
							script_help filesystem_help
							filesystem_menu "${gv_Auswahl#HELP }"
							;;
						$gv_Display)
							# Ansicht ueber die btrfs Laufwerke# {{{
							autoload -U kwbtrfs_filesystem_show
							kwbtrfs_filesystem_show
							## }}}
							filesystem_menu $gv_Display
							;;
						$lv_Detail)
							# detailierte Ansicht ueber die btrfs Laufwerke# {{{
							autoload -U kwbtrfs_filesystem_usage
							kwbtrfs_filesystem_usage
							## }}}
							filesystem_menu $gv_Detail
							;;
						$lv_Df)
							# Ansicht ueber die belegten Bloecke von btrfs Laufwerken# {{{
							autoload -U kwbtrfs_filesystem_df
							kwbtrfs_filesystem_df
							## }}}
							filesystem_menu $lv_Df
							;;
						$lv_Defrag)
							# Defragmentierung eines btrfs Laufwerks# {{{
							autoload -U kwbtrfs_filesystem_defrag
							kwbtrfs_filesystem_defrag
							## }}}
							filesystem_menu $lv_Defrag
							;;
						$lv_Label)
							# Label aendern, einfuegen# {{{
							autoload -U kwbtrfs_filesystem_label
							kwbtrfs_filesystem_label
							## }}}
							filesystem_menu $lv_Label
							;;
						$gv_Enlarge)
							# Dateisystem vergroessern# {{{
							#
							hier_ist_noch_nichts $gv_Enlarge
							## }}}
							filesystem_menu $gv_Enlarge
							;;
						$gv_Reduce)
							# Dateisystem verkleinern# {{{
							#
							hier_ist_noch_nichts $gv_Reduce
							## }}}
							filesystem_menu $gv_Reduce
							;;
						$lv_Sync)
							# Dateisystem synchronisieren# {{{
							# ###############
							# TODO: nur RAID Arrays?
							hier_ist_noch_nichts $lv_Sync
							## }}}
							filesystem_menu $lv_Sync
							;;
						$gv_Back)
						# zurueck
						break
						;;
					esac
				done
			else
				no_btrfs_dev_msg
			fi
			## }}}
			main_menu $lv_Filesystem
			;;
		$lv_Subvolumes)
			# Subvolumes# {{{
			# Variablen# {{{
			lv_Subvolume=$(gettext 'Subvolume')
			lv_Snapshot=$(gettext 'Snapshot')
			lv_Findnew=$(gettext 'Zustand Dateien')
			lv_DefaultId=$(gettext 'Subvolume IDs')
			## }}}
			# Funktion (subvolumes_menu)# {{{
			#
			subvolumes_menu() {
				MENU=($gv_Display \"\" $gv_Create \"\" $gv_Delete \"\"
				$lv_Snapshot \"\" \"$lv_Findnew\" \"\" \"$lv_DefaultId\" \"\"
				$gv_Back \"\")
				menubox "$1" "$lv_Subvolumes" "$gv_Menupoint" "$MENU"
			}
			## }}}
			# Funktion (no_subvolume_msg), Nachricht das keine Subvolumes vorhanden sind# {{{
			#
			no_subvolume_msg() {
				MSG=$(gettext 'Es sind keine $lv_Subvolumes vorhanden.')
				msgbox "$gv_Info" "$MSG"
			}
			## }}}
			# Funktion (search_subvolumes), suche nach Subvolumes# {{{
			#
			search_subvolumes() {
				unset -- SUBVOL_DEV SUBVOL_DEV_E SUBVOL_DEV_M SUBVOL_ID SUBVOL_MOUNT_DEVS
				for i in ${=BTRFS_DEV} ; {
					mount_check -c $i
					if [[ $MOUNT == no ]] ; then
						MOUNT_DEV=(${gv_WorkDir}/${i##*/})
						mkdir $MOUNT_DEV &>/dev/null
						if mount -o rw -t btrfs $i $MOUNT_DEV &>/dev/null ; then
							MOUNT_DEVS+=($MOUNT_DEV)
							btrfs subvolume list -tu $MOUNT_DEV >${gv_WorkDir}/subvolumes
							list_subvolumes
						fi
					else
						MOUNT_DEV=($MOUNTPOINT)
						btrfs subvolume list -tu $MOUNT_DEV >${gv_WorkDir}/subvolumes
						list_subvolumes
					fi
				}
			}
			## }}}
			# Funktion (list_subvolumes), listet Subvolumes auf# {{{
			#
			list_subvolumes() {
				if [[ -s ${gv_WorkDir}/subvolumes ]] ; then
					while read id gen tl uuid s ; do
						# suche nach subvol=/subvolumename
						Tmp="`print ${${(s: :)${(M)${(f)"$(mount)"}##*subvol=/${s}*}}[3]}`"
						
						if [[ ! -n $Tmp ]] ; then
							if [[ ! -d ${MOUNT_DEV%/}/${s} ]] ; then
								mkdir ${MOUNT_DEV%/}/${s} &>/dev/null
							fi
							if mount -t btrfs -o subvol=${s},rw $i ${MOUNT_DEV%/}/${s} &>/dev/null ; then
								SUBVOL_MOUNT_DEVS+=(${MOUNT_DEV%/}/${s})
								SUBVOL_DEV+=(${MOUNT_DEV%/}/${s})
								SUBVOL_DEV_E+=(${MOUNT_DEV%/}/${s} \"\")
								SUBVOL_DEV_M+=(${MOUNT_DEV%/}/${s} \"\" off)
								SUBVOL_ID+=($id)
							fi
						else
							SUBVOL_DEV+=($Tmp)
							SUBVOL_DEV_E+=($Tmp \"\")
							SUBVOL_DEV_M+=($Tmp \"\" off)
							SUBVOL_ID+=($id)
						fi
					done < ${gv_WorkDir}/subvolumes
				else
					no_subvolume_msg
				fi
			}
			## }}}
			# Funktion (subvol_checklist), Subvolumes zur Auswahl anzeigen# {{{
			#
			subvol_checklist() {
				MENU=($SUBVOL_DEV_M)
				MSG=$(gettext 'Waehlen Sie ein oder mehrere btrfs $lv_Subvolumes aus.')
				checklist "$1" "$lv_Subvolumes" "$MSG" "$MENU"
			}
			## }}}
			# Funktion (subvol_snapshot_choice_menu), Subvolumes zur Auswahl anzeigen# {{{
			#
			subvol_snapshot_choice_menu() {
				MENU=($SUBVOL_DEV_E $gv_Back \"\")
				MSG=$(gettext 'Waehlen Sie ein btrfs $lv_Subvolume aus.')
				menubox "$1" "${lv_Subvolumes}::${lv_Snapshot}::${lv_Subvolume}" "$MSG" "$MENU"
			}
			## }}}
			#
			search_btrfs_filesystem
			if [[ -n ${BTRFS_DEV[1]} ]] ; then
				subvolumes_menu
				while [ -n "$gv_Auswahl" ] ; do
					case $gv_Auswahl in
						HELP*)
							# Hilfe
							script_help subvolumes_help
							subvolumes_menu "${gv_Auswahl#HELP }"
							;;
						$gv_Display)
							# Anzeige der vorhandenen Subvolumes# {{{
							autoload -U kwbtrfs_subvolumes_display
							kwbtrfs_subvolumes_display
							## }}}
							subvolumes_menu "$gv_Display"
							;;
						$gv_Create)
							# Subvolume erstellen# {{{
							autoload -U kwbtrfs_subvolumes_create
							kwbtrfs_subvolumes_create
							## }}}
							subvolumes_menu "$gv_Create"
							;;
						$gv_Delete)
							# Subvolumes loeschen# {{{
							autoload -U kwbtrfs_subvolumes_delete
							kwbtrfs_subvolumes_delete
							## }}}
							subvolumes_menu "$gv_Delete"
							;;
						$lv_Snapshot)
							# Snapshot eines Subvolume erstellen.# {{{
							autoload -U kwbtrfs_subvolumes_snapshot
							kwbtrfs_subvolumes_snapshot
							## }}}
							subvolumes_menu "$lv_Snapshot"
							;;
						$lv_Findnew)
							# Anzeige vom Zustand der Dateien# {{{
							autoload -U kwbtrfs_subvolumes_findnew
							kwbtrfs_subvolumes_findnew
							## }}}
							subvolumes_menu "$lv_Findnew"
							;;
						$lv_DefaultId)
							# Ids fuer die Subvolumes setzen.# {{{
							autoload -U kwbtrfs_subvolumes_id
							kwbtrfs_subvolumes_id
							## }}}
							subvolumes_menu "$lv_DefaultId"
							;;
						$gv_Back)
							# zurueck
							break
							;;
					esac
				done
			else
				no_btrfs_dev_msg
			fi
			## }}}
			main_menu $lv_Subvolumes
			;;
		$lv_Devices)
			# Management fuer multiple Devices, wie z.B. RAID# {{{
			lv_Options=$(gettext 'Optionen')
			lv_Raid=$(gettext 'RAID')
			lv_Is_Drive=$(gettext 'btrfs Laufwerk')
			lv_Encrypt_Raid=$(gettext 'verschluesseltes RAID')
			lv_Device_Convert=$(gettext 'Laufwerk konvertieren')
			lv_Device_Add=$(gettext 'Laufwerke hinzufuegen')
			lv_Device_Remove=$(gettext 'Laufwerke entfernen')
			lv_Device_Replace=$(gettext 'Laufwerk tauschen')
			lv_Src_Device=$(gettext 'Quelllaufwerk')
			lv_Target_Device=$(gettext 'Ziellaufwerk')
			#
			# Funktion (device_menu)# {{{
			#
			device_menu() {
				MENU=($gv_Display \"\" $gv_Create \"\" \"$lv_Device_Convert\" \"\"
				\"$lv_Device_Add\" \"\" \"$lv_Device_Remove\" \"\"
				\"$lv_Device_Replace\" \"\" $gv_Back \"\")
				menubox "$1" "$lv_Devices" "$gv_Menupoint" "$MENU"
			}
			## }}}
			# Funktion (create_menu)# {{{
			#
			create_menu() {
				MENU=($lv_Drive \"\" $lv_Raid \"\" \"$lv_Encrypt_Raid\" \"\"
					$gv_Back \"\")
				menubox "$1" "$lv_Devices" "$gv_Menupoint" "$MENU"
			}
			## }}}
			device_menu
			while [ -n "$gv_Auswahl" ] ; do
				case $gv_Auswahl in
					HELP*)
						# Hilfe
						script_help devices_help
						device_menu "${gv_Auswahl#HELP }"
						;;
					$gv_Display)
						# Detaillierte Informationen ueber btrfs Laufwerke,#{{{
						# anzeigen
						search_btrfs_filesystem
						if [[ -n ${BTRFS_DEV[1]} ]] ; then
							mount_btrfs_dev_check
							btrfs_dev_checklist "${lv_Devices}::${gv_Display}"
							while [[ $gv_Auswahl_Display ]] ; do
								case $gv_Auswahl in
									HELP*)
										# Hilfe
										script_help devices_usage_help
										btrfs_dev_checklist "${lv_Devices}::${gv_Display}" "${gv_Auswahl#HELP }"
										;;
									/*)
										# Information ueber die ausgewaehlten Laufwerke# {{{
										# anzeigen
										rm -rf ${gv_WorkDir}/btrfs_usage &>/dev/null
										for i in ${=gv_Auswahl} ; {
											echo "$i" >>${gv_WorkDir}/btrfs_usage
											echo "--------------------------------" >>${gv_WorkDir}/btrfs_usage
											btrfs device usage -h "$i" >>${gv_WorkDir}/btrfs_usage
										}
										view_file ${gv_WorkDir}/btrfs_usage
										## }}}
										btrfs_dev_checklist "${lv_Devices}::${gv_Display}" "${gv_Auswahl[1]}"
										;;
									*)
										# zurueck
										break
										;;
								esac
							done
						else
							no_btrfs_dev_msg
						fi
						## }}}
						device_menu "$gv_Display"
						;;
					$gv_Create)
						# btrfs Laufwerke, RAID Arrays erstellen# {{{
						create_menu
						while [ -n "$gv_Auswahl" ] ; do
							case $gv_Auswahl in
								HELP*)
									script_help device_create_help
									create_menu "${gv_Auswahl#HELP }"
									;;
								$lv_Drive)
									# Laufwerke mit BTRFS formatieren# {{{
									autoload -U kwbtrfs_drive_format
									kwbtrfs_drive_format
									## }}}
									create_menu $lv_Drive
									;;
								$lv_Raid)
									# RAID erstellen# {{{
									autoload -U kwbtrfs_raid_create_conf
									kwbtrfs_raid_create_conf
									## }}}
									create_menu $lv_Raid
									;;
								$lv_Encrypt_Raid)
									# verschluesseltes RAID erstellen# {{{
									autoload -U kwbtrfs_raid_create_conf
									kwbtrfs_raid_create_conf -c
									## }}}
									create_menu $lv_Encrypt_Raid
									;;
								$gv_Back)
									# zuruecck
									break
									;;
							esac
						done
						## }}}
						device_menu "$gv_Create"
						;;
					$lv_Device_Convert)
						# ext[234] Laufwerk nach btrfs konvertieren# {{{
						autoload -U kwbtrfs_drive_convert
						kwbtrfs_drive_convert
						## }}}
						device_menu "$lv_Device_Convert"
						;;
					$lv_Device_Add)
						# Laufwerk hinzufuegen# {{{
						autoload -U kwbtrfs_device_add
						kwbtrfs_device_add
						## }}}
						device_menu "$lv_Device_Add"
						;;
					$lv_Device_Remove)
						# Festplatte/Partition entfernen# {{{
						autoload -U kwbtrfs_device_remove
						kwbtrfs_device_remove
						## }}}
						device_menu "$lv_Device_Remove"
						;;
					$lv_Device_Replace)
						# Festplatte/Partition austauschen# {{{
						autoload -U kwbtrfs_device_replace
						kwbtrfs_device_replace
						## }}}
						device_menu "$lv_Device_Replace"
						;;
					$gv_Back)
						# zurueck
						break
						;;
				esac
			done
			## }}}
			main_menu $lv_Devices
			;;
		$lv_Balance)
			# Metadatenabgleich# {{{
			hier_ist_noch_nichts $lv_Balance
			## }}}
			main_menu $lv_Balance
			;;
		$gv_Exit)	break
			;;
	esac
done	
#
umount_dev
exit 0

### Modeline {{{
### vim:ft=zsh:foldmethod=marker
### vim:set ts=4: 
### }}}
